### A Pluto.jl notebook ###
# v0.19.36

using Markdown
using InteractiveUtils

# ╔═╡ 7923696e-c798-40e2-a038-070bcf52cccb
md"""
# 5 自定义类型（高级）
在Python中， 我们可以编写类（Class）。一个类， 有自己的数据和相应的方法。 在Julia中， 我们仍然可以编写自己的数据类型， 但方法已经不再是跟数据绑定在一起了。 编写自定义的数据类型（复合类型）很简单， 只需要用struct关键字：
```
[mutable] struct Typename
field1
field2
...
end
```
默认的复合内容是不可修改的， 为了让结构中各个域可修改， 可在定义之前加关键字mutable。 此外， struct的各个域也可以通过`::Type`指定相应的类型。 

通常情况下， 数据类型会有自动生成构造函数。 默认的构造函数， 函数名就是类型名， 参数会依次赋值给每一个域。如果数据类型不同， 会尝试用convert转换后去赋值， 如果转换不了， 则会构造失败。 下面的代码可以定义平面上的一个点（x, y）。 然后用`Point2D(3, 4)`则可以生成一个具体的点。
```
struct Point2D
	x::Float32
	y::Float32
end
```

在一些高级语言中， 我们可以定义类(class)， 类中同时具有数据和可以绑定方法。 Julia的自定义类型不能在类型定义时定义方法。 但我们可以基于类型定义相应的函数（这种函数， 有时候称为函子）。 比如， 下面的代码我们希望定义一个多项式， 用coeffs来存储多项式的系数：
```
struct Polynomial
	coeffs
end
```
定义了这个多项式的表示类型之后， 我们可以定义该类型绑定的函数如下， 这个函数没有函数名， 函数名对应的是一个类型名， 前面的p在具体调用的时候会指向类型的对象。
```
function (p::Polynomial)(x)
	v = p.coeffs[end]
for i = (length(p.coeffs)-1):-1:1 
	v = v*x + p.coeffs[i]
end
	return v
end
```

此后， 在我们构造了类型的对象之后， 我们就可以用对象去调用这个函数了。 
```
t = Polynomial([1,10,100])
t(5)
```

这种通过给类型加方法使得类型的对象变得可被调用的机制(有点类似于Python中通过class定义数据和方法的过程)， 在一些高级的编程场合使用非常广泛， 比如， 在神经网络中， 就可以通过这种方式定义一种特殊的数据类型， 代表特殊的网络层， 然后定义相应的类型方法， 在初始化之后， 就可以通过对象去计算结果了。 可以把这种机制看成是面向对象编程的一种模拟。
"""

# ╔═╡ cfce213e-3657-4d14-a86c-73e34ab9866d
struct Point2D
x::Float32
y::Float32
end

# ╔═╡ e0aab4d3-7832-475d-94e8-3918248f1b3d
md"""
## 复合类型Composite Type
在面向对象的编程语言中， 比如Python， 我们可以定义自己的类（class）。一个类可以包含一些字段（数据）， 同时也会有这个类的对象可以调用的相关函数（方法）。 一般， 类实例化之后被称为对象（object）。要调用相关函数， 我们需要使用`对象.方法`这样的语法形式， 这表明， 方法是由对象的类决定的。 在Julia中， 数据和方法是分开的。决定调用何种方法是由函数的位置参数共同决定的（多重分派），而不仅仅是函数的第一个参数。这种将数据跟方法解耦的方式具有非常多的优势。

因此， 在Julia中，我们不能定义类， 但可以定义包含一些字段的数据类型--复合类型。简单来说， 复合类型就是一个把多个名字绑定为一个整体的数据类型。 类似在C语言中， Julia使用struct关键字定义复合类型。
```julia
struct Point
	x
	y
end
```
上面定义了一个名为Point的复合类型。在该类型中， 有两个名字(字段field)。 这个定义很简单， 你可以给两个字段赋予任何的值。因为，我们没有对字段的数据类型做任何的限制， 这种情况下是默认类型Any。当然， 对于特定的应用来说， 我们限制字段的类型是有好处的（可以获得更快的代码）。如果我们要对类型做出限制， 可以使用类型断言符--两个冒号`::` 

```julia
struct Point
	x::Float32
	y::Float32
end
```
在这个定义里， 我们限制了字段的类型的字段只能是32位的浮点数。 
"""

# ╔═╡ 30aeb721-c5de-4011-9159-ca8b0b1a5f1b
md"""
在Julia中， 如果我们定义类型的话， 习惯上， 使用大写字母开头的名字，涉及多个单词时， 每个单词首字母大写
""" |> kuoz

# ╔═╡ 3d39117c-7011-497c-914e-5043c0aa08a2
struct Point
	x::Float32
	y::Float32
end

# ╔═╡ deb6c1c6-7bf1-48b2-b6d4-7ee7dacb9969
fieldnames(Point)

# ╔═╡ 8ffa29ef-ab8e-440f-917e-0e713ecb7b63
p = Point(2,3)

# ╔═╡ d5cb8de2-55ee-4719-b1af-87b8dc0430f0
p.x, p.y

# ╔═╡ f4e02b42-8fab-4dff-80dc-3db96a76a9c9
md"""
用struct直接定义的类型默认是不可修改的。比如，下面试图修改p的坐标的操作会失败。
"""

# ╔═╡ 7c55f112-671c-4f1f-b3ec-22f1f75b8b38
p.x = 4

# ╔═╡ 2383630b-f436-4569-b991-b77b2b38e88b
md"""
如果要定义可以修改的类型， 需要在struct的前面加mutable关键词。即如下定义：
```julia
[mutable] struct Typename
field1
field2
...
end
```
"""

# ╔═╡ b99159a2-3060-4aff-a3e5-67095ab582b8
md"""
## 构造函数
定义了复合类型之后， 如何构造复合类型的对象呢？ 简单来说, 把复合类型像函数一样调用就可以得到一个该类型的对象。 比如，上面定义的Point， 那么我们可以通过`Point（2,3）`构造一个点（2,3）。 我们可以通过 `对象.字段名` 的方式获取对象的特定字段的值。 你可以通过`fieldnames(类型名)`函数获取一个类型的所有的字段名。
"""

# ╔═╡ 0a3e8baa-d462-4b31-9f51-ceb499bea05c
md"""
我们把一个复合类型当成函数调用， 实际上是调用了类的默认构造函数`constructor`。 一般一个复合类型在定义之后， Julia会自动为其提供两个默认构造函数：一个接受任意类型参数的构造函数和一个接受精确类型参数的构造函数。 接受任意类型参数的构造函数会自动调用convert函数将参数转化为类型指定的类型。 比如， 上面构造的点p， 我们输入的数据是整数2,3， 但仍然能正确构造出对象，是因为整数可以转化为浮点数。
"""

# ╔═╡ 28f7ab8b-9769-4141-9e0f-c7fd2337bb2a
p.x, p.y

# ╔═╡ b6deb0d6-fc23-4b36-aa90-2a99e7b09ef4
md"""
### Ex4. 用结构体重写Ex2.
在建模过程中， 我们对原始数据施加了某个变换， 当新的样本来临时， 我们仍需要进行同样的变换才能用于模型的预测。 这时候， 我们需要将变换保存起来， 在后续碰到新的数据时， 再使用它去做变换。 这意味着， 我们需要存储变换过程中使用到的值。 为了实现这一点， 我们用一个结构体表示一个变换。

下面先定义最小-最大变换结构体。

""" |> lianx

# ╔═╡ 464c22b1-95cc-4ccb-a7f6-36daaf2a46e9
mutable struct MinMax
	dn
	up
end

# ╔═╡ d7506a49-ac06-4d58-bd57-1ba2aecebd4f
md"""
因为我们会在模型训练的时候修改这个结构体中存的值。所以我们需要将模型定义为mutable的。

有了结构体之后， 相当于我们有了一个抽象的变换。 当我们给定一个向量去“训练”后， 我们就可以用这个变换去变换数据了。
"""

# ╔═╡ c8bd7ef5-8d6c-4890-b4f5-d7618ea10565
function fit!(t::MinMax, v)
	t.dn = minimum(v)
	t.up = maximum(v)
end

# ╔═╡ d9914cdc-ea19-4f8f-8222-26e7cd7b1341
T1 = MinMax(0,0)

# ╔═╡ 994a1afa-23ae-4943-93f0-f273a741672c
fit!(T1, [4,5,6,7,10])

# ╔═╡ cc1f1bfa-d908-4af0-ae96-138146c54f04
T1

# ╔═╡ beca5496-1748-44f0-8dbc-123db3586072
function transform(T::MinMax, v)
	(v .- T.dn) ./ (T.up - T.dn)
end

# ╔═╡ 7a737533-1108-4568-a688-9e41c88ea48d
transform(T1, [4,5,6,7,10])

# ╔═╡ 59aa4dc5-7189-4753-bd6f-dc3f001ef6df
md"""
当有新的数据需要转换时
"""

# ╔═╡ 3a1d6911-6842-4e04-be03-2c13e62f586c
transform(T1, [8,12])

# ╔═╡ 52752dc6-fd37-43fb-a497-a9a8893fc79a
md"""
有时候， 可能还需要逆变换， 比如知道变换后的值是 0.7， 变换之前是多少？
"""

# ╔═╡ 1b929cc3-d456-4d22-8ea2-641f6b2c3c92
function inverse_transform(t::MinMax, v)
	v .* (t.up - t.dn) + t.dn
end

# ╔═╡ 44cd23a2-5a89-44c6-924b-afdc0c1d8f26
inverse_transform(T1, 0.166667)

# ╔═╡ Cell order:
# ╠═7923696e-c798-40e2-a038-070bcf52cccb
# ╠═cfce213e-3657-4d14-a86c-73e34ab9866d
# ╠═e0aab4d3-7832-475d-94e8-3918248f1b3d
# ╠═30aeb721-c5de-4011-9159-ca8b0b1a5f1b
# ╠═3d39117c-7011-497c-914e-5043c0aa08a2
# ╠═deb6c1c6-7bf1-48b2-b6d4-7ee7dacb9969
# ╠═8ffa29ef-ab8e-440f-917e-0e713ecb7b63
# ╠═d5cb8de2-55ee-4719-b1af-87b8dc0430f0
# ╠═f4e02b42-8fab-4dff-80dc-3db96a76a9c9
# ╠═7c55f112-671c-4f1f-b3ec-22f1f75b8b38
# ╠═2383630b-f436-4569-b991-b77b2b38e88b
# ╠═b99159a2-3060-4aff-a3e5-67095ab582b8
# ╠═0a3e8baa-d462-4b31-9f51-ceb499bea05c
# ╠═28f7ab8b-9769-4141-9e0f-c7fd2337bb2a
# ╠═b6deb0d6-fc23-4b36-aa90-2a99e7b09ef4
# ╠═464c22b1-95cc-4ccb-a7f6-36daaf2a46e9
# ╠═d7506a49-ac06-4d58-bd57-1ba2aecebd4f
# ╠═c8bd7ef5-8d6c-4890-b4f5-d7618ea10565
# ╠═d9914cdc-ea19-4f8f-8222-26e7cd7b1341
# ╠═994a1afa-23ae-4943-93f0-f273a741672c
# ╠═cc1f1bfa-d908-4af0-ae96-138146c54f04
# ╠═beca5496-1748-44f0-8dbc-123db3586072
# ╠═7a737533-1108-4568-a688-9e41c88ea48d
# ╠═59aa4dc5-7189-4753-bd6f-dc3f001ef6df
# ╠═3a1d6911-6842-4e04-be03-2c13e62f586c
# ╠═52752dc6-fd37-43fb-a497-a9a8893fc79a
# ╠═1b929cc3-d456-4d22-8ea2-641f6b2c3c92
# ╠═44cd23a2-5a89-44c6-924b-afdc0c1d8f26
